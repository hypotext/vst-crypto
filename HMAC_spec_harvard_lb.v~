Set Implicit Arguments.


Require Import Bvector.
Require Import List.
Require Import Arith.

Require Import HMAC_functional_prog.
Require Import Integers.
Require Import Coqlib.

(* Require Import List. Import ListNotations. *)

Definition Blist := list bool.

Fixpoint splitVector(A : Set)(n m : nat) : Vector.t A (n + m) -> (Vector.t A n * Vector.t A m) :=
  match n with
    | 0%nat => 
      fun (v : Vector.t A (O + m)) => (@Vector.nil A, v)
    | S n' => 
      fun (v : Vector.t A (S n' + m)) => 
        let (v1, v2) := splitVector _ _ (Vector.tl v) in
          (Vector.cons _ (Vector.hd v) _ v1, v2)
  end.

Section HMAC.

SearchAbout Bvector.
Print Bvector.
Check Bvector 10.
Check [true]. 
Print Vector.

(* TODO what are b, c, p? why b + b? what is 2k? *)
(* key + padding? *)
  Variable c p : nat.
  (* len of padded key? *)
  Definition b := (c + p)%nat.
(* Variable b : nat. *)
  Check b.
  
  (* The compression function *)
  Variable h : Bvector c -> Bvector b -> Bvector c.
  (* The initialization vector is part of the spec of the hash function. *)
  Variable iv : Bvector c.
  (* The iteration of the compression function gives a keyed hash function on lists of words. *)
  Definition h_star k (m : list (Bvector b)) :=
    fold_left h m k.
  (* The composition of the keyed hash function with the IV gives a hash function on lists of words. *)
  (* TODO check how this corresponds to SHA *)
  Definition hash_words := h_star iv.
Check hash_words.
Check h_star.

  Variable splitAndPad : Blist -> list (Bvector b).

  (* TODO examine this hypothesis *)
  Hypothesis splitAndPad_1_1 : 
    forall b1 b2,
      splitAndPad b1 = splitAndPad b2 ->
      b1 = b2.
  
  (* constant-length padding. *)
  Variable fpad : Bvector p.

  Definition app_fpad (x : Bvector c) : Bvector b :=
    (Vector.append x fpad).
  Definition h_star_pad k x :=
    app_fpad (h_star k x).

  Definition GNMAC k m :=
    let (k_Out, k_In) := splitVector c c k in
    h k_Out (app_fpad (h_star k_In m)).

  (* The "two-key" version of GHMAC and HMAC. *)
  (* Concatenate (K xor opad) and (K xor ipad) *)
  Definition GHMAC_2K (k : Bvector (b + b)) m :=
    let (k_Out, k_In) := splitVector b b k in (* concat earlier, then split *)
      let h_in := (hash_words (k_In :: m)) in 
        hash_words (k_Out :: (app_fpad h_in) :: nil).
  
  (* b + b comes from ( *)
  Definition HMAC_2K (k : Bvector (b + b)) (m : Blist) :=
    GHMAC_2K k (splitAndPad m).

Check HMAC_2K.
(* HMAC_2K
     : Bvector (b + b) -> Blist -> Bvector c *)
SearchAbout Bvector.
(* Bvector (b + b) -> Blist -> BVector c *)

Print splitVector.

Theorem test : forall (k : Bvector (b + b)) (m : Blist),
  HMAC_2K k m = HMAC_2K k m.
Proof.
  intros k m.
  unfold HMAC_2K.               (* splitAndPad is abstract *)
  unfold GHMAC_2K.
  unfold hash_words.
  unfold h_star. 
  (* unfold splitVector. *)
Abort.

Print Bvector.                  (* Vector.t bool : nat -> Set *)
(* Check [true]%(Bvector 1). *)
(* Cannot compute since Variables are not instantiated  -- TODO, how to instantiate 
(e.g. with SHA256? does it have the right type? 
SHA256 : list Z -> list Z *)
(* Eval compute in HMAC_2K [true; true] [false]. *)

  (* opad and ipad are constants defined in the HMAC spec. *)
  Variable opad ipad : Bvector b.
  Definition GHMAC (k : Bvector b) :=
    GHMAC_2K (Vector.append (BVxor _ k opad) (BVxor _ k ipad)).

Print BVxor.

  (* Doesn't seem to take into account the hash function's input block size (see mkKey in P. spec) *)
  Definition HMAC (k : Bvector b) :=
    HMAC_2K (Vector.append (BVxor _ k opad) (BVxor _ k ipad)).

Check HMAC.                     (*  : Bvector b -> Blist -> Bvector c *)

  (* Bvector is little-endian (least significant bit at head; list Z are just translated
from the string (ascii -> nat -> Z); but Int are packed big-endian (with 4 Z -> 1 Int)

each Z is one byte (8 bits) *

bytes -> bits is ok
bits -> bytes is not ok
*)

  (* Bvector or Blist? *)
Check HMAC_2K.                  (* TODO confirm that this is actually the right version *)
Print Vector.t.

(* TODO: add isbyteZ (from SHA256.v), 0 <= i <= 256 *)
(* Definition byte_to_bits (byte : Z) : list bool := *)
  (* nil. *)
  
SearchAbout Bvector.

(*
Fixpoint bytes_to_bits (bytes : list Z) : Bvector (length bytes * 8) :=
  match bytes with
    | nil => []
    | x :: xs => byte_to_bits x bytes_to_bits xs
  end.
*)

(* Have not instantiated anything *)
(* Variable byte_to_bits (l : list Z) : Bvector (length l * 8). *)
(*
Variable bytes_to_bits : list Z -> Bvector c.

Theorem HMAC_equiv : forall (l msg : list Z) 
                            (* need to convert list Z -> Bvector (b + b)
                             and list Z -> Blist *)
                            (l' : Bvector (b + b)) (m' : Blist),
  bytes_to_bits (HMAC_FUN.HMAC l msg) = HMAC_2K l' m'. (* Bvector c *)
Proof.
  intros l m l' m'.
Abort.  
*)
End HMAC.

(* -------------- *)

(*Require Import HMAC_functional_prog_2.*)

(* How to get the other HMAC? *)
(* TODO: compile HMAC_functional_prog_2 *)
Check HMAC_SHA256.HMAC.            (* list Z -> list Z -> list Z *)

(* Bvector (plus c p)  *)

(* relationship between a list Z (of bytes) and a Bvector of size (c + p):
toBvector (bytes_to_bits k) = K?
(don't actually need the Bvector, just c + p, or its length) <-- deprecated,
want equality
 *)
Inductive bytes_bits_vector (c p : nat) (k : list Z) : Bvector (plus c p) -> Prop :=
  | test_n : forall (K : Bvector (plus c p)), bytes_bits_vector c p k K (* ?? TODO *)
.

(* relating list Z to Blist
bytes_to_bits m = length M

TODO: big-endian, little-endian?
*)
Inductive bytes_bits_lists (m : list Z) : Blist -> Prop :=
  | test_n' : forall M : Blist, bytes_bits_lists m M
.

(* the hashes are "the same": list Z vs Bvector c

toBvector (bytes_to_bits h) = H
this is *almost* the same as bytes_bits_vector, except just c, not c + p
 *)
Inductive bytes_bits_vector' (c : nat) (h : list Z) : Bvector c -> Prop :=
  | test_n'' : forall (H : Bvector c), bytes_bits_vector' h H
.
(* TODO: compare to rel1. How do dependent types and inductive props work? *)

Check bytes_bits_vector.
Check HMAC_SHA256.HMAC.         (* ? *)
Check HMAC.
(* HMAC
     : forall c p : nat,
       (Bvector c -> Bvector (b c p) -> Bvector c) ->   // compression function h
       Bvector c ->                          // iv, h's initialization vector
       (Blist -> list (Bvector (b c p))) ->  // splitAndPad (e.g. generate_and_pad)
       Bvector p ->                          // fpad, constant-length padding
       Bvector (b c p) ->                    // opad
       Bvector (b c p) ->                    // ipad

^ Note: this has to do with the internals of SHA256 and HMAC too
SHA's compression function, iv, generate_and_pad (with block vectors),
HMAC's key padding function, HMAC's opad and ipad

How to convert?

Bvector (b c p) -> Blist -> Bvector c        // key, message, outputted hash
k is of length b
b = block size
c = output size
c + p = output size padded to block size

why pad the key? why not just let it be size b?
 *)

(* Is this the theorem we want? Is it useful for the rest of the proofs?
Should it be more abstract? 

also, no key padding
add assumption that the key is padded to the right length (b)
password of length b
modify?
*)

Print Blist.

(* maybe bvector of length 8, convert to Blist later? *)
Parameter byte_to_bits : Z -> Bvector 8.
  (* Vector.nil bool. TODO *)



(* Or: concatMap byte_to_bit bytes *)
Check Bvector.
SearchAbout Bvector.
Print Vector.t.

(* how to prove that it's length bytes * 8? *)
(* list of bytes? (type) *)
Fixpoint bytes_to_bits (bytes : list Z) : Bvector (length bytes * 8) :=
  match bytes as x return Bvector (length x * 8) with (* CPDT *)
    | nil => Vector.nil bool
    | x :: xs => Vector.append (byte_to_bits x) (bytes_to_bits xs)
  end.
Print N.
SearchAbout nat.

SearchAbout Vector.t.

Parameter sha_iv : Bvector (SHA256.DigestLength * 8).

(* Definition sha_h : list Z -> list Z := SHA256_.Hash. *)
Parameter sha_h : forall (c p : nat) (b:nat -> nat -> nat), Bvector c -> Bvector (b c p) -> Bvector c.

(* corresponds to block size
b = plus *)

(* TODO: email adam about fpad: it's not padding the key *)

(*  "Blist -> list (Bvector (b SHA256_.DigestLength c))" *)
(*Parameter sha_splitandpad_vector :
  forall (c p: nat), Blist -> list (Bvector (SHA256.DigestLength)).*)
Parameter sha_splitandpad_vector :
  forall (p: nat), Blist -> list (Bvector (SHA256.DigestLength * 8 + p)).

Parameter fpad : forall (p : nat), Bvector p.

(* want Bvector b = 512 bits *)
Print Byte.int.
Print Byte.repr.
Check HMAC_SHA256.sixtyfour HMAC_SHA256.Opad.
Check Byte.unsigned.
Definition opad := 
     bytes_to_bits
                     (map Byte.unsigned (HMAC_SHA256.sixtyfour HMAC_SHA256.Opad)).
Check opad. 
Definition ipad := bytes_to_bits
                     (map Byte.unsigned (HMAC_SHA256.sixtyfour HMAC_SHA256.Ipad)).

Check HMAC.

(* 
Email Adam about fpad
Email Lennart this file
Figure out what parameters are
Fill in the relations
 *)
Check HMAC.
Module Equiv.

Definition c:nat.
 Proof. Print ex apply ((SHA256.DigestLength * 8)%nat). 
 Defined.
Definition c:nat := (SHA256.DigestLength * 8)%nat.
(*Variable p:nat.
Locate HMAC.
Check @HMAC. Check @sha_h.
Check (@HMAC _ p (@sha_h _ p plus) sha_iv (sha_splitandpad_vector p) (fpad p)). 
Check (HMAC (sha_h p plus) sha_iv).
*)
Definition p:=(32 * 8)%nat.
Theorem HMAC_spec_equiv : forall
                            
                            (k m h : list Z)
                            (K : Bvector (plus c p)) (M : Blist) (H : Bvector c) OP IP,
                            
  (8 * (length k))%nat = b c p ->
  bytes_bits_vector c p k K -> bytes_bits_lists m M ->
  HMAC (sha_h p plus) sha_iv (sha_splitandpad_vector p) (fpad p) OP IP K M = H ->
  HMAC_SHA256.HMAC k m = h ->
  (* TODO fix HMAC h iv splitAndPad fpad opad ipad K M *)
  bytes_bits_vector' h H.
intros. unfold p,c, b in *. simpl in *. 
Theorem HMAC_spec_equiv : forall
                            (p : nat)
                            (k m h : list Z)
                            (K : Bvector (plus c p)) (M : Blist) (H : Bvector c) OP IP,
                            
  (8 * (length k))%nat = b c p ->
  bytes_bits_vector c p k K -> bytes_bits_lists m M ->
  HMAC (sha_h p plus) sha_iv (sha_splitandpad_vector p) (fpad p) OP IP K M = H ->
  HMAC_SHA256.HMAC k m = h ->
  (* TODO fix HMAC h iv splitAndPad fpad opad ipad K M *)
  bytes_bits_vector' h H.

Proof.

Abort.

