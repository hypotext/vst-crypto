Set Implicit Arguments.

Require Import Bvector.
Require Import List.
Require Import Arith.

Definition Blist := list bool.

Fixpoint splitVector(A : Type)(n m : nat) : Vector.t A (n + m) -> (Vector.t A n * Vector.t A m) :=
  match n with
    | 0 => 
      fun (v : Vector.t A (O + m)) => (@Vector.nil A, v)
    | S n' => 
      fun (v : Vector.t A (S n' + m)) => 
        let (v1, v2) := splitVector _ _ (Vector.tl v) in
          (Vector.cons _ (Vector.hd v) _ v1, v2)
  end.

Definition vectorMinus_eq(A : Type)(n m : nat)(_ : (n <= m)%nat)(x : Vector.t A (n + (m - n))) : Vector.t A m.
rewrite le_plus_minus_r in x; trivial.
Defined.

Section HMAC.

  Variable c b : nat.
  Hypothesis b_ge_c : b >= c.
  
  (* The compression function *)
  Variable h : Bvector c -> Bvector b -> Bvector c.
  (* The initialization vector is part of the spec of the hash function. *)
  Variable iv : Bvector c.
  (* The iteration of the compression function gives a keyed hash function on lists of words. *)
  Definition h_star k (m : list (Bvector b)) :=
    fold_left h m k.
  (* The composition of the keyed hash function with the IV gives a hash function on lists of words. *)
  Definition hash_words := h_star iv.
  
  (* The splitList function takes a list of bits and returns a list of words and the leftover bits at the end.  We'll want to construct this function at some point.  *)
  Variable splitList : Blist -> list (Bvector b) * Blist.
  Hypothesis splitList_last_small : 
    forall x, (length (snd (splitList x)) <= b)%nat.

  Definition pad (ls : Blist) :=
    Vector.const true (b - (length ls)).
  Definition splitAndPad(x : Blist) : list (Bvector b) :=
      let lastV := vectorMinus_eq (splitList_last_small x) 
        (Vector.append (Vector.of_list (snd (splitList x))) (pad (snd (splitList x)))) in
      (fst (splitList x)) ++ (lastV :: nil).
  
  (* constant-length padding. *)
  Variable fpad : Bvector (b - c).
 
  Definition app_fpad (x : Bvector c) : Bvector b :=
    vectorMinus_eq b_ge_c (Vector.append x fpad).


  (* The "two-key" version of GHMAC and HMAC. *)
  Definition GHMAC_2K (k : Bvector (b + b)) m :=
    let (k_Out, k_In) := splitVector b b k in
      let h_in := (hash_words (k_In :: m)) in 
        hash_words (k_Out :: (app_fpad h_in) :: nil).
  
  Definition HMAC_2K (k : Bvector (b + b)) (m : Blist) :=
    GHMAC_2K k (splitAndPad m).

  (* opad and ipad are constants defined in the HMAC spec. *)
  Variable opad ipad : Bvector b.
  Definition HMAC (k : Bvector b) :=
    HMAC_2K (Vector.append (BVxor _ k opad) (BVxor _ k ipad)).


End HMAC.